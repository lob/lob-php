<?php
/**
 * Letter
 *
 * PHP version 7.3
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Lob
 *
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> Looking for our [previous documentation](https://lob.github.io/legacy-docs/)?
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: lob-openapi@lob.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * Letter Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class Letter implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'letter';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'to' => '\OpenAPI\Client\Model\Address',
        'from' => '\OpenAPI\Client\Model\Address',
        'carrier' => 'string',
        'thumbnails' => '\OpenAPI\Client\Model\Thumbnail[]',
        'expected_delivery_date' => '\DateTime',
        'date_created' => '\DateTime',
        'date_modified' => '\DateTime',
        'deleted' => 'bool',
        'id' => 'string',
        'template_id' => 'string',
        'template_version_id' => 'string',
        'object' => 'string',
        'description' => 'string',
        'metadata' => 'array<string,string>',
        'merge_variables' => 'object',
        'send_date' => '\DateTime',
        'extra_service' => 'string',
        'tracking_number' => 'string',
        'tracking_events' => '\OpenAPI\Client\Model\TrackingEventNormal[]',
        'return_address' => 'string',
        'mail_type' => '\OpenAPI\Client\Model\MailType',
        'color' => 'bool',
        'double_sided' => 'bool',
        'address_placement' => 'string',
        'return_envelope' => 'mixed',
        'perforated_page' => 'int',
        'custom_envelope' => '\OpenAPI\Client\Model\LetterCustomEnvelope'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'to' => null,
        'from' => null,
        'carrier' => null,
        'thumbnails' => null,
        'expected_delivery_date' => 'date',
        'date_created' => 'date-time',
        'date_modified' => 'date-time',
        'deleted' => null,
        'id' => null,
        'template_id' => null,
        'template_version_id' => null,
        'object' => null,
        'description' => null,
        'metadata' => null,
        'merge_variables' => null,
        'send_date' => 'date-time',
        'extra_service' => null,
        'tracking_number' => null,
        'tracking_events' => null,
        'return_address' => null,
        'mail_type' => null,
        'color' => null,
        'double_sided' => null,
        'address_placement' => null,
        'return_envelope' => null,
        'perforated_page' => null,
        'custom_envelope' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'to' => 'to',
        'from' => 'from',
        'carrier' => 'carrier',
        'thumbnails' => 'thumbnails',
        'expected_delivery_date' => 'expected_delivery_date',
        'date_created' => 'date_created',
        'date_modified' => 'date_modified',
        'deleted' => 'deleted',
        'id' => 'id',
        'template_id' => 'template_id',
        'template_version_id' => 'template_version_id',
        'object' => 'object',
        'description' => 'description',
        'metadata' => 'metadata',
        'merge_variables' => 'merge_variables',
        'send_date' => 'send_date',
        'extra_service' => 'extra_service',
        'tracking_number' => 'tracking_number',
        'tracking_events' => 'tracking_events',
        'return_address' => 'return_address',
        'mail_type' => 'mail_type',
        'color' => 'color',
        'double_sided' => 'double_sided',
        'address_placement' => 'address_placement',
        'return_envelope' => 'return_envelope',
        'perforated_page' => 'perforated_page',
        'custom_envelope' => 'custom_envelope'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'to' => 'setTo',
        'from' => 'setFrom',
        'carrier' => 'setCarrier',
        'thumbnails' => 'setThumbnails',
        'expected_delivery_date' => 'setExpectedDeliveryDate',
        'date_created' => 'setDateCreated',
        'date_modified' => 'setDateModified',
        'deleted' => 'setDeleted',
        'id' => 'setId',
        'template_id' => 'setTemplateId',
        'template_version_id' => 'setTemplateVersionId',
        'object' => 'setObject',
        'description' => 'setDescription',
        'metadata' => 'setMetadata',
        'merge_variables' => 'setMergeVariables',
        'send_date' => 'setSendDate',
        'extra_service' => 'setExtraService',
        'tracking_number' => 'setTrackingNumber',
        'tracking_events' => 'setTrackingEvents',
        'return_address' => 'setReturnAddress',
        'mail_type' => 'setMailType',
        'color' => 'setColor',
        'double_sided' => 'setDoubleSided',
        'address_placement' => 'setAddressPlacement',
        'return_envelope' => 'setReturnEnvelope',
        'perforated_page' => 'setPerforatedPage',
        'custom_envelope' => 'setCustomEnvelope'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'to' => 'getTo',
        'from' => 'getFrom',
        'carrier' => 'getCarrier',
        'thumbnails' => 'getThumbnails',
        'expected_delivery_date' => 'getExpectedDeliveryDate',
        'date_created' => 'getDateCreated',
        'date_modified' => 'getDateModified',
        'deleted' => 'getDeleted',
        'id' => 'getId',
        'template_id' => 'getTemplateId',
        'template_version_id' => 'getTemplateVersionId',
        'object' => 'getObject',
        'description' => 'getDescription',
        'metadata' => 'getMetadata',
        'merge_variables' => 'getMergeVariables',
        'send_date' => 'getSendDate',
        'extra_service' => 'getExtraService',
        'tracking_number' => 'getTrackingNumber',
        'tracking_events' => 'getTrackingEvents',
        'return_address' => 'getReturnAddress',
        'mail_type' => 'getMailType',
        'color' => 'getColor',
        'double_sided' => 'getDoubleSided',
        'address_placement' => 'getAddressPlacement',
        'return_envelope' => 'getReturnEnvelope',
        'perforated_page' => 'getPerforatedPage',
        'custom_envelope' => 'getCustomEnvelope'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const CARRIER_USPS = 'USPS';
    const OBJECT_LETTER = 'letter';
    const ADDRESS_PLACEMENT_TOP_FIRST_PAGE = 'top_first_page';
    const ADDRESS_PLACEMENT_INSERT_BLANK_PAGE = 'insert_blank_page';
    const ADDRESS_PLACEMENT_BOTTOM_FIRST_PAGE_CENTER = 'bottom_first_page_center';
    const ADDRESS_PLACEMENT_BOTTOM_FIRST_PAGE = 'bottom_first_page';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCarrierAllowableValues()
    {
        return [
            self::CARRIER_USPS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getObjectAllowableValues()
    {
        return [
            self::OBJECT_LETTER,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAddressPlacementAllowableValues()
    {
        return [
            self::ADDRESS_PLACEMENT_TOP_FIRST_PAGE,
            self::ADDRESS_PLACEMENT_INSERT_BLANK_PAGE,
            self::ADDRESS_PLACEMENT_BOTTOM_FIRST_PAGE_CENTER,
            self::ADDRESS_PLACEMENT_BOTTOM_FIRST_PAGE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['to'] = $data['to'] ?? null;
        $this->container['from'] = $data['from'] ?? null;
        $this->container['carrier'] = $data['carrier'] ?? null;
        $this->container['thumbnails'] = $data['thumbnails'] ?? null;
        $this->container['expected_delivery_date'] = $data['expected_delivery_date'] ?? null;
        $this->container['date_created'] = $data['date_created'] ?? null;
        $this->container['date_modified'] = $data['date_modified'] ?? null;
        $this->container['deleted'] = $data['deleted'] ?? null;
        $this->container['id'] = $data['id'] ?? null;
        $this->container['template_id'] = $data['template_id'] ?? null;
        $this->container['template_version_id'] = $data['template_version_id'] ?? null;
        $this->container['object'] = $data['object'] ?? null;
        $this->container['description'] = $data['description'] ?? null;
        $this->container['metadata'] = $data['metadata'] ?? null;
        $this->container['merge_variables'] = $data['merge_variables'] ?? null;
        $this->container['send_date'] = $data['send_date'] ?? null;
        $this->container['extra_service'] = $data['extra_service'] ?? null;
        $this->container['tracking_number'] = $data['tracking_number'] ?? null;
        $this->container['tracking_events'] = $data['tracking_events'] ?? null;
        $this->container['return_address'] = $data['return_address'] ?? null;
        $this->container['mail_type'] = $data['mail_type'] ?? null;
        $this->container['color'] = $data['color'] ?? null;
        $this->container['double_sided'] = $data['double_sided'] ?? null;
        $this->container['address_placement'] = $data['address_placement'] ?? null;
        $this->container['return_envelope'] = $data['return_envelope'] ?? null;
        $this->container['perforated_page'] = $data['perforated_page'] ?? null;
        $this->container['custom_envelope'] = $data['custom_envelope'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['to'] === null) {
                $invalidProperties[] = "'to' can't be null";
            }
        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['from'] === null) {
                $invalidProperties[] = "'from' can't be null";
            }
        }
        $allowedValues = $this->getCarrierAllowableValues();
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['carrier']) && !in_array($this->container['carrier'], $allowedValues, true)) {
                $invalidProperties[] = sprintf(
                    "invalid value '%s' for 'carrier', must be one of '%s'",
                    $this->container['carrier'],
                    implode("', '", $allowedValues)
                );
            }
        }

        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['date_created'] === null) {
                $invalidProperties[] = "'date_created' can't be null";
            }
        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['date_modified'] === null) {
                $invalidProperties[] = "'date_modified' can't be null";
            }
        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['id'] === null) {
                $invalidProperties[] = "'id' can't be null";
            }
        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!preg_match("/^ltr_[a-zA-Z0-9]+$/", $this->container['id'])) {
                $invalidProperties[] = "invalid value for 'id', must be conform to the pattern /^ltr_[a-zA-Z0-9]+$/.";
            }

        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['template_id']) && !preg_match("/^tmpl_[a-zA-Z0-9]+$/", $this->container['template_id'])) {
                $invalidProperties[] = "invalid value for 'template_id', must be conform to the pattern /^tmpl_[a-zA-Z0-9]+$/.";
            }

        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['template_version_id']) && !preg_match("/^vrsn_[a-zA-Z0-9]+$/", $this->container['template_version_id'])) {
                $invalidProperties[] = "invalid value for 'template_version_id', must be conform to the pattern /^vrsn_[a-zA-Z0-9]+$/.";
            }

        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['object'] === null) {
                $invalidProperties[] = "'object' can't be null";
            }
        }
        $allowedValues = $this->getObjectAllowableValues();
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['object']) && !in_array($this->container['object'], $allowedValues, true)) {
                $invalidProperties[] = sprintf(
                    "invalid value '%s' for 'object', must be one of '%s'",
                    $this->container['object'],
                    implode("', '", $allowedValues)
                );
            }
        }

        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['description']) && (mb_strlen($this->container['description']) > 255)) {
                $invalidProperties[] = "invalid value for 'description', the character length must be smaller than or equal to 255.";
            }

        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
        }
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['tracking_events']) && (count($this->container['tracking_events']) > 0)) {
                $invalidProperties[] = "invalid value for 'tracking_events', number of items must be less than or equal to 0.";
            }

        }
        $allowedValues = $this->getAddressPlacementAllowableValues();
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($this->container['address_placement']) && !in_array($this->container['address_placement'], $allowedValues, true)) {
                $invalidProperties[] = sprintf(
                    "invalid value '%s' for 'address_placement', must be one of '%s'",
                    $this->container['address_placement'],
                    implode("', '", $allowedValues)
                );
            }
        }

        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if ($this->container['return_envelope'] === null) {
                $invalidProperties[] = "'return_envelope' can't be null";
            }
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }

    

    /**
     * Gets to
     *
     * @return \OpenAPI\Client\Model\Address
     */
    public function getTo()
    {
        return $this->container['to'];
    }

    /**
     * Sets to
     *
     * @param \OpenAPI\Client\Model\Address $to to
     *
     * @return self
     */
    public function setTo($to)
    {
        $this->container['to'] = $to;

        return $this;
    }


    /**
     * Gets from
     *
     * @return \OpenAPI\Client\Model\Address
     */
    public function getFrom()
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param \OpenAPI\Client\Model\Address $from from
     *
     * @return self
     */
    public function setFrom($from)
    {
        $this->container['from'] = $from;

        return $this;
    }


    /**
     * Gets carrier
     *
     * @return string|null
     */
    public function getCarrier()
    {
        return $this->container['carrier'];
    }

    /**
     * Sets carrier
     *
     * @param string|null $carrier carrier
     *
     * @return self
     */
    public function setCarrier($carrier)
    {
        $allowedValues = $this->getCarrierAllowableValues();
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($carrier) && !in_array($carrier, $allowedValues, true)) {
                throw new \InvalidArgumentException(
                    sprintf(
                        "Invalid value '%s' for 'carrier', must be one of '%s'",
                        $carrier,
                        implode("', '", $allowedValues)
                    )
                );
            }
        }

        $this->container['carrier'] = $carrier;

        return $this;
    }


    /**
     * Gets thumbnails
     *
     * @return \OpenAPI\Client\Model\Thumbnail[]|null
     */
    public function getThumbnails()
    {
        return $this->container['thumbnails'];
    }

    /**
     * Sets thumbnails
     *
     * @param \OpenAPI\Client\Model\Thumbnail[]|null $thumbnails thumbnails
     *
     * @return self
     */
    public function setThumbnails($thumbnails)
    {
        $this->container['thumbnails'] = [];
        if ($thumbnails) {
            foreach ($thumbnails as $point) {
                $deserializedData = ObjectSerializer::deserialize($point, '\OpenAPI\Client\Model\Thumbnail', []);
                
                array_push($this->container['thumbnails'], $deserializedData);
            }
        }

        return $this;
    }


    /**
     * Gets expected_delivery_date
     *
     * @return \DateTime|null
     */
    public function getExpectedDeliveryDate()
    {
        return $this->container['expected_delivery_date'];
    }

    /**
     * Sets expected_delivery_date
     *
     * @param \DateTime|null $expected_delivery_date A date in YYYY-MM-DD format of the mailpiece's expected delivery date based on its `send_date`.
     *
     * @return self
     */
    public function setExpectedDeliveryDate($expected_delivery_date)
    {
        $this->container['expected_delivery_date'] = $expected_delivery_date;

        return $this;
    }


    /**
     * Gets date_created
     *
     * @return \DateTime
     */
    public function getDateCreated()
    {
        return $this->container['date_created'];
    }

    /**
     * Sets date_created
     *
     * @param \DateTime $date_created A timestamp in ISO 8601 format of the date the resource was created.
     *
     * @return self
     */
    public function setDateCreated($date_created)
    {
        $this->container['date_created'] = $date_created;

        return $this;
    }


    /**
     * Gets date_modified
     *
     * @return \DateTime
     */
    public function getDateModified()
    {
        return $this->container['date_modified'];
    }

    /**
     * Sets date_modified
     *
     * @param \DateTime $date_modified A timestamp in ISO 8601 format of the date the resource was last modified.
     *
     * @return self
     */
    public function setDateModified($date_modified)
    {
        $this->container['date_modified'] = $date_modified;

        return $this;
    }


    /**
     * Gets deleted
     *
     * @return bool|null
     */
    public function getDeleted()
    {
        return $this->container['deleted'];
    }

    /**
     * Sets deleted
     *
     * @param bool|null $deleted Only returned if the resource has been successfully deleted.
     *
     * @return self
     */
    public function setDeleted($deleted)
    {
        $this->container['deleted'] = $deleted;

        return $this;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id Unique identifier prefixed with `ltr_`.
     *
     * @return self
     */
    public function setId($id)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {

            if ((!preg_match("/^ltr_[a-zA-Z0-9]+$/", $id))) {
                throw new \InvalidArgumentException("invalid value for $id when calling Letter., must conform to the pattern /^ltr_[a-zA-Z0-9]+$/.");
            }

        }
        $this->container['id'] = $id;

        return $this;
    }


    /**
     * Gets template_id
     *
     * @return string|null
     */
    public function getTemplateId()
    {
        return $this->container['template_id'];
    }

    /**
     * Sets template_id
     *
     * @param string|null $template_id Unique identifier prefixed with `tmpl_`. ID of a saved [HTML template](#section/HTML-Templates).
     *
     * @return self
     */
    public function setTemplateId($template_id)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {

            if (!is_null($template_id) && (!preg_match("/^tmpl_[a-zA-Z0-9]+$/", $template_id))) {
                throw new \InvalidArgumentException("invalid value for $template_id when calling Letter., must conform to the pattern /^tmpl_[a-zA-Z0-9]+$/.");
            }

        }
        $this->container['template_id'] = $template_id;

        return $this;
    }


    /**
     * Gets template_version_id
     *
     * @return string|null
     */
    public function getTemplateVersionId()
    {
        return $this->container['template_version_id'];
    }

    /**
     * Sets template_version_id
     *
     * @param string|null $template_version_id Unique identifier prefixed with `vrsn_`.
     *
     * @return self
     */
    public function setTemplateVersionId($template_version_id)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {

            if (!is_null($template_version_id) && (!preg_match("/^vrsn_[a-zA-Z0-9]+$/", $template_version_id))) {
                throw new \InvalidArgumentException("invalid value for $template_version_id when calling Letter., must conform to the pattern /^vrsn_[a-zA-Z0-9]+$/.");
            }

        }
        $this->container['template_version_id'] = $template_version_id;

        return $this;
    }


    /**
     * Gets object
     *
     * @return string
     */
    public function getObject()
    {
        return $this->container['object'];
    }

    /**
     * Sets object
     *
     * @param string $object object
     *
     * @return self
     */
    public function setObject($object)
    {
        $allowedValues = $this->getObjectAllowableValues();
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!in_array($object, $allowedValues, true)) {
                throw new \InvalidArgumentException(
                    sprintf(
                        "Invalid value '%s' for 'object', must be one of '%s'",
                        $object,
                        implode("', '", $allowedValues)
                    )
                );
            }
        }

        $this->container['object'] = $object;

        return $this;
    }


    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description An internal description that identifies this resource. Must be no longer than 255 characters.
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($description) && (mb_strlen($description) > 255)) {
                throw new \InvalidArgumentException('invalid length for $description when calling Letter., must be smaller than or equal to 255.');
            }

        }
        $this->container['description'] = $description;

        return $this;
    }


    /**
     * Gets metadata
     *
     * @return array<string,string>|null
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param array<string,string>|null $metadata Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. '{\"customer_id\" : \"NEWYORK2015\"}' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
     *
     * @return self
     */
    public function setMetadata($metadata)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {


        }
        $this->container['metadata'] = $metadata;

        return $this;
    }


    /**
     * Gets merge_variables
     *
     * @return object|null
     */
    public function getMergeVariables()
    {
        return $this->container['merge_variables'];
    }

    /**
     * Sets merge_variables
     *
     * @param object|null $merge_variables You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: `{{variable_name}}`, pass in `{\"variable_name\": \"Harry\"}` to render `Harry`. `merge_variables` must be an object. Any type of value is accepted as long as the object is valid JSON; you can use `strings`, `numbers`, `booleans`, `arrays`, `objects`, or `null`. The max length of the object is 25,000 characters. If you call `JSON.stringify` on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: `!`, `\"`, `#`, `%`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `/`, `;`, `<`, `=`, `>`, `@`, `[`, `\\`, `]`, `^`, `` ` ``, `{`, `|`, `}`, `~`. More instructions can be found in [our guide to using html and merge variables](https://lob.com/resources/guides/general/using-html-and-merge-variables). Depending on your [Merge Variable strictness](https://dashboard.lob.com/#/settings/account) setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.
     *
     * @return self
     */
    public function setMergeVariables($merge_variables)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {


        }
        $this->container['merge_variables'] = $merge_variables;

        return $this;
    }


    /**
     * Gets send_date
     *
     * @return \DateTime|null
     */
    public function getSendDate()
    {
        return $this->container['send_date'];
    }

    /**
     * Sets send_date
     *
     * @param \DateTime|null $send_date A timestamp in ISO 8601 format which specifies a date after the current time and up to 180 days in the future to send the letter off for production. Setting a send date overrides the default [cancellation window](#section/Cancellation-Windows) applied to the mailpiece. Until the `send_date` has passed, the mailpiece can be canceled. If a date in the format `2017-11-01` is passed, it will evaluate to midnight UTC of that date (`2017-11-01T00:00:00.000Z`). If a datetime is passed, that exact time will be used. A `send_date` passed with no time zone will default to UTC, while a `send_date` passed with a time zone will be converted to UTC.
     *
     * @return self
     */
    public function setSendDate($send_date)
    {
        $this->container['send_date'] = $send_date;

        return $this;
    }


    /**
     * Gets extra_service
     *
     * @return string|null
     */
    public function getExtraService()
    {
        return $this->container['extra_service'];
    }

    /**
     * Sets extra_service
     *
     * @param string|null $extra_service Add an extra service to your letter. See [pricing](https://www.lob.com/pricing/print-mail#compare) for extra costs incurred.
     *
     * @return self
     */
    public function setExtraService($extra_service)
    {
        $this->container['extra_service'] = $extra_service;

        return $this;
    }


    /**
     * Gets tracking_number
     *
     * @return string|null
     */
    public function getTrackingNumber()
    {
        return $this->container['tracking_number'];
    }

    /**
     * Sets tracking_number
     *
     * @param string|null $tracking_number The tracking number, if applicable, will appear here when it becomes available. Dummy tracking numbers are not created in test mode.
     *
     * @return self
     */
    public function setTrackingNumber($tracking_number)
    {
        $this->container['tracking_number'] = $tracking_number;

        return $this;
    }


    /**
     * Gets tracking_events
     *
     * @return \OpenAPI\Client\Model\TrackingEventNormal[]|null
     */
    public function getTrackingEvents()
    {
        return $this->container['tracking_events'];
    }

    /**
     * Sets tracking_events
     *
     * @param \OpenAPI\Client\Model\TrackingEventNormal[]|null $tracking_events Tracking events are not populated for registered or regular (no extra service) letters.
     *
     * @return self
     */
    public function setTrackingEvents($tracking_events)
    {
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {

            if (!is_null($tracking_events) && (count($tracking_events) > 0)) {
                throw new \InvalidArgumentException('invalid value for $tracking_events when calling Letter., number of items must be less than or equal to 0.');
            }
        }
        $this->container['tracking_events'] = [];
        if ($tracking_events) {
            foreach ($tracking_events as $point) {
                $deserializedData = ObjectSerializer::deserialize($point, '\OpenAPI\Client\Model\TrackingEventNormal', []);
                
                array_push($this->container['tracking_events'], $deserializedData);
            }
        }

        return $this;
    }


    /**
     * Gets return_address
     *
     * @return string|null
     */
    public function getReturnAddress()
    {
        return $this->container['return_address'];
    }

    /**
     * Sets return_address
     *
     * @param string|null $return_address Specifies the address the return envelope will be sent back to. This is an optional argument that is available if an account is signed up for the return envelope tracking beta, and has `return_envelope`, and `perforated_page` fields populated in the API request.
     *
     * @return self
     */
    public function setReturnAddress($return_address)
    {
        $this->container['return_address'] = $return_address;

        return $this;
    }


    /**
     * Gets mail_type
     *
     * @return \OpenAPI\Client\Model\MailType|null
     */
    public function getMailType()
    {
        return $this->container['mail_type'];
    }

    /**
     * Sets mail_type
     *
     * @param \OpenAPI\Client\Model\MailType|null $mail_type mail_type
     *
     * @return self
     */
    public function setMailType($mail_type)
    {
        $this->container['mail_type'] = $mail_type;

        return $this;
    }


    /**
     * Gets color
     *
     * @return bool|null
     */
    public function getColor()
    {
        return $this->container['color'];
    }

    /**
     * Sets color
     *
     * @param bool|null $color Set this key to `true` if you would like to print in color. Set to `false` if you would like to print in black and white.
     *
     * @return self
     */
    public function setColor($color)
    {
        $this->container['color'] = $color;

        return $this;
    }


    /**
     * Gets double_sided
     *
     * @return bool|null
     */
    public function getDoubleSided()
    {
        return $this->container['double_sided'];
    }

    /**
     * Sets double_sided
     *
     * @param bool|null $double_sided Set this attribute to `true` for double sided printing, or `false` for for single sided printing. Defaults to `true`.
     *
     * @return self
     */
    public function setDoubleSided($double_sided)
    {
        $this->container['double_sided'] = $double_sided;

        return $this;
    }


    /**
     * Gets address_placement
     *
     * @return string|null
     */
    public function getAddressPlacement()
    {
        return $this->container['address_placement'];
    }

    /**
     * Sets address_placement
     *
     * @param string|null $address_placement Specifies the location of the address information that will show through the double-window envelope.
     *
     * @return self
     */
    public function setAddressPlacement($address_placement)
    {
        $allowedValues = $this->getAddressPlacementAllowableValues();
        if (!method_exists($this, 'getId') || (!empty($this->getId()) && strpos($this->getId(), "fakeId") === False)) {
            if (!is_null($address_placement) && !in_array($address_placement, $allowedValues, true)) {
                throw new \InvalidArgumentException(
                    sprintf(
                        "Invalid value '%s' for 'address_placement', must be one of '%s'",
                        $address_placement,
                        implode("', '", $allowedValues)
                    )
                );
            }
        }

        $this->container['address_placement'] = $address_placement;

        return $this;
    }


    /**
     * Gets return_envelope
     *
     * @return mixed
     */
    public function getReturnEnvelope()
    {
        return $this->container['return_envelope'];
    }

    /**
     * Sets return_envelope
     *
     * @param mixed $return_envelope return_envelope
     *
     * @return self
     */
    public function setReturnEnvelope($return_envelope)
    {
        $this->container['return_envelope'] = $return_envelope;

        return $this;
    }


    /**
     * Gets perforated_page
     *
     * @return int|null
     */
    public function getPerforatedPage()
    {
        return $this->container['perforated_page'];
    }

    /**
     * Sets perforated_page
     *
     * @param int|null $perforated_page Required if `return_envelope` is `true`. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to `1`. The blank page added by `address_placement=insert_blank_page` will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our [perforation guide](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf).
     *
     * @return self
     */
    public function setPerforatedPage($perforated_page)
    {
        $this->container['perforated_page'] = $perforated_page;

        return $this;
    }


    /**
     * Gets custom_envelope
     *
     * @return \OpenAPI\Client\Model\LetterCustomEnvelope|null
     */
    public function getCustomEnvelope()
    {
        return $this->container['custom_envelope'];
    }

    /**
     * Sets custom_envelope
     *
     * @param \OpenAPI\Client\Model\LetterCustomEnvelope|null $custom_envelope custom_envelope
     *
     * @return self
     */
    public function setCustomEnvelope($custom_envelope)
    {
        $this->container['custom_envelope'] = $custom_envelope;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


