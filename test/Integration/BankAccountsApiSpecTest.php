<?php
/**
 * BankAccountsApiSpecTest
 * PHP version 7.3
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Lob
 *
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> Looking for our [previous documentation](https://lob.github.io/legacy-docs/)?
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: lob-openapi@lob.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Please update the test case below to test the endpoint.
 */

namespace OpenAPI\Client\Test\Api;

use \OpenAPI\Client\Configuration;
use \OpenAPI\Client\ApiException;
use PHPUnit\Framework\TestCase;
use \OpenAPI\Client\Api\BankAccountsApi;
use \OpenAPI\Client\Model\BankAccountVerify;
use \OpenAPI\Client\Model\BankAccountWritable;
use \OpenAPI\Client\Model\BankTypeEnum;

/**
 * BankAccountsApiSpecTest Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

class BankAccountsApiSpecTest extends TestCase
{
    /**
     * Setup before running any test cases
     */
    private static $config;
    private static $bankApi;
    private static $invalidBankApi;
    private static $writableBankAcc;
    private static $errorBank;
    private static $ba1;
    private static $ba2;
    private static $ba3;
    private static $bankVerify;
    private static $metadata;

    // for teardown post-testing
    private $idsForCleanup = [];

    // set up constant fixtures
    public static function setUpBeforeClass(): void
    {
        // create instance of BankAccountsApi & editable bank accounts for other tests
        self::$config = new Configuration();
        self::$config->setApiKey("basic", getenv("LOB_API_TEST_KEY"));
        self::$bankApi = new BankAccountsApi(self::$config);

        $invalid_config = new Configuration();
        $invalid_config->setApiKey("basic", "Totally Fake Key");
        self::$invalidBankApi = new BankAccountsApi($invalid_config);

        self::$writableBankAcc = new BankAccountWritable();
        self::$writableBankAcc->setDescription("PHP test bank account");
        self::$writableBankAcc->setRoutingNumber("322271627");
        self::$writableBankAcc->setAccountNumber("123456789");
        self::$writableBankAcc->setSignatory("Sinead Connor");
        self::$writableBankAcc->setAccountType(BankTypeEnum::INDIVIDUAL->value);

        self::$errorBank = new BankAccountWritable();
        self::$errorBank->setDescription("PHP error bank account");
        self::$errorBank->setAccountNumber("123456789");
        self::$errorBank->setSignatory("Sinead Connor");
        self::$errorBank->setAccountType(BankTypeEnum::INDIVIDUAL->value);

        self::$bankVerify = new BankAccountVerify();
        self::$bankVerify->setAmounts([11, 35]);

        // for testing list function
        self::$ba1 = new BankAccountWritable();
        self::$ba1->setDescription("PHP test listing bank account 1");
        self::$ba1->setRoutingNumber("322271627");
        self::$ba1->setAccountNumber("123456789");
        self::$ba1->setSignatory("Eilis Connor");
        self::$ba1->setAccountType(BankTypeEnum::INDIVIDUAL->value);

        self::$ba2 = new BankAccountWritable();
        self::$ba2->setDescription("PHP test listing bank account 2");
        self::$ba2->setRoutingNumber("322271627");
        self::$ba2->setAccountNumber("123456789");
        self::$ba2->setSignatory("Ronan Connor");
        self::$ba2->setAccountType(BankTypeEnum::INDIVIDUAL->value);

        self::$ba3 = new BankAccountWritable();
        self::$ba3->setDescription("PHP test listing bank account 2");
        self::$ba3->setRoutingNumber("322271627");
        self::$ba3->setAccountNumber("123456789");
        self::$ba3->setSignatory("Niamh Connor");
        self::$ba3->setAccountType(BankTypeEnum::INDIVIDUAL->value);
        self::$metadata = (object)array("name"=>"Harry");
        self::$ba3->setMetadata(self::$metadata);
    }

    public function tearDown(): void
    {
        foreach ($this->idsForCleanup as $id) {
            self::$bankApi->delete($id);
        }
    }

    public function testBankAccountsApiInstantiation200() {
        $baApi200 = new BankAccountsApi(self::$config);
        $this->assertEquals(gettype($baApi200), "object");
    }

    public function testCreate200()
    {
        $createdBankAccount = self::$bankApi->create(self::$writableBankAcc);
        $this->assertMatchesRegularExpression("/bank_/", $createdBankAccount->getId());
        array_push($this->idsForCleanup, $createdBankAccount->getId());
    }

    // does not include required field in request
    public function testCreate422()
    {
        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/routing_number is required/");
        $errorResponse = self::$bankApi->create(self::$errorBank);
    }

    // uses a bad key to attempt to send a request
    public function testBankAccountApi401() {
        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/Your API key is not valid. Please sign up on lob.com to get a valid api key./");
        $errorResponse = self::$invalidBankApi->create(self::$writableBankAcc);
    }

    public function testVerify200()
    {
        $createdBankAccount = self::$bankApi->create(self::$writableBankAcc);
        $verifiedBankAccount = self::$bankApi->verify($createdBankAccount->getId(), self::$bankVerify);
        $this->assertMatchesRegularExpression("/bank_/", $createdBankAccount->getId());
        array_push($this->idsForCleanup, $createdBankAccount->getId());
    }

    public function testVerify401()
    {
        $createdBankAccount = self::$bankApi->create(self::$writableBankAcc);
        array_push($this->idsForCleanup, $createdBankAccount->getId());

        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/Your API key is not valid/");
        $verifiedBankAccount = self::$invalidBankApi->verify($createdBankAccount->getId(), self::$bankVerify);
    }

    public function testVerify404()
    {
        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/not found/");
        $verifiedBankAccount = self::$bankApi->verify("bank_fakeId", self::$bankVerify);
    }

    public function testGet200()
    {
        $createdAcc = self::$bankApi->create(self::$writableBankAcc);
        $retrievedAcc = self::$bankApi->get($createdAcc->getId());
        $this->assertEquals($createdAcc->getRoutingNumber(), $retrievedAcc->getRoutingNumber());
        array_push($this->idsForCleanup, $createdAcc->getId());
    }

    public function testGet401()
    {
        $createdBankAccount = self::$bankApi->create(self::$writableBankAcc);
        array_push($this->idsForCleanup, $createdBankAccount->getId());

        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/Your API key is not valid/");
        $badRetrieval = self::$invalidBankApi->get($createdBankAccount->getId());
    }

    public function testGet404()
    {
        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/bank account not found/");
        $badRetrieval = self::$bankApi->get("bank_NONEXISTENT");
    }

    public function testList200()
    {
        $nextUrl = "";
        $previousUrl = "";
        $bank1 = self::$bankApi->create(self::$ba1);
        $bank2 = self::$bankApi->create(self::$ba2);
        $bank3 = self::$bankApi->create(self::$ba3);
        $listedBankAccounts = self::$bankApi->list(3);
        $this->assertGreaterThan(1, count($listedBankAccounts->getData()));
        $this->assertLessThanOrEqual(3, count($listedBankAccounts->getData()));
        $nextUrl = substr($listedBankAccounts->getNextUrl(), strrpos($listedBankAccounts->getNextUrl(), "after=") + 6);
        $this->assertIsString($nextUrl);
        array_push($this->idsForCleanup, $bank1->getId());
        array_push($this->idsForCleanup, $bank2->getId());
        array_push($this->idsForCleanup, $bank3->getId());

        // response using nextUrl
        if ($nextUrl != "") {
            $bank1 = self::$bankApi->create(self::$ba1);
            $bank2 = self::$bankApi->create(self::$ba2);
            $bank3 = self::$bankApi->create(self::$ba3);
            $listedBankAccountsAfter = self::$bankApi->list(3, null, $nextUrl);
            $this->assertGreaterThan(1, count($listedBankAccountsAfter->getData()));
            $this->assertLessThanOrEqual(3, count($listedBankAccountsAfter->getData()));
            $previousUrl = substr($listedBankAccountsAfter->getPreviousUrl(), strrpos($listedBankAccountsAfter->getPreviousUrl(), "before=") + 7);
            $this->assertIsString($previousUrl);
            array_push($this->idsForCleanup, $bank1->getId());
            array_push($this->idsForCleanup, $bank2->getId());
            array_push($this->idsForCleanup, $bank3->getId());
        }

        // response using previousUrl
        if ($previousUrl != "") {
            $bank1 = self::$bankApi->create(self::$ba1);
            $bank2 = self::$bankApi->create(self::$ba2);
            $bank3 = self::$bankApi->create(self::$ba3);
            $listedBankAccountsBefore = self::$bankApi->list(3, $previousUrl);
            $this->assertGreaterThan(1, count($listedBankAccountsBefore->getData()));
            $this->assertLessThanOrEqual(3, count($listedBankAccountsBefore->getData()));
            array_push($this->idsForCleanup, $bank1->getId());
            array_push($this->idsForCleanup, $bank2->getId());
            array_push($this->idsForCleanup, $bank3->getId());
        }
    }

    public function provider()
    {
        date_default_timezone_set('America/Los_Angeles');
        $date_str = date("Y-m-d", strtotime("-1 months"));
        $date_obj = (object) array("gt" => $date_str);

        return array(
          array(null, null, null, array("total_count"), null, null),
          array(null, null, null, null, $date_obj, null),
          array(null, null, null, null, null, self::$metadata),
        );
    }

    /**
     * @dataProvider provider
     */
    public function testListWithParams($limit, $before, $after, $include, $date_created, $metadata)
    {
        // create bank accounts to list
        $bank1 = self::$bankApi->create(self::$ba1);
        $bank2 = self::$bankApi->create(self::$ba2);
        $bank3 = self::$bankApi->create(self::$ba3);
        $listedBankAccounts = self::$bankApi->list($limit, $before, $after, $include, $date_created, $metadata);

        $this->assertGreaterThan(0, $listedBankAccounts->getCount());
        if ($include) $this->assertNotNull($listedBankAccounts->getTotalCount());

        // delete created bank accounts
        array_push($this->idsForCleanup, $bank1->getId());
        array_push($this->idsForCleanup, $bank2->getId());
        array_push($this->idsForCleanup, $bank3->getId());
    }

    public function testDelete200()
    {
        $createdAcc = self::$bankApi->create(self::$writableBankAcc);
        $deletedAcc = self::$bankApi->delete($createdAcc->getId());
        $this->assertEquals(true, $deletedAcc->getDeleted());
        $this->assertMatchesRegularExpression("/bank_/", $deletedAcc->getId());
    }

    public function testDelete401()
    {
        $createdBankAccount = self::$bankApi->create(self::$writableBankAcc);
        array_push($this->idsForCleanup, $createdBankAccount->getId());

        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/Your API key is not valid/");
        $badRetrieval = self::$invalidBankApi->delete($createdBankAccount->getId());
    }


    public function testDelete404()
    {
        $this->expectException(\Exception::class);
        $this->expectExceptionMessageMatches("/bank account not found/");
        $badDeletion = self::$bankApi->delete("bank_NONEXISTENT");
    }
}
